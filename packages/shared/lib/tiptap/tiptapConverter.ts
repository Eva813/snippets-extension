/**
 * TipTap JSON è½‰æ›å·¥å…·
 * å°‡ TipTap JSON æ ¼å¼è½‰æ›ç‚ºç´”æ–‡å­—æˆ– HTMLï¼Œçµ±ä¸€ç®¡ç†è½‰æ›é‚è¼¯
 */

import { generateHTML } from '@tiptap/html';
import TipTapStarterKit from '@tiptap/starter-kit';
import TipTapTextStyle from '@tiptap/extension-text-style';
import TipTapTextAlign from '@tiptap/extension-text-align';
import { createFormNode } from './formNodeFactory';
import { formTextRenderStrategy, formMenuRenderStrategy } from './renderStrategies';
import { FORM_NODE_TYPES } from '../form/constants';
import { logger } from '../logging/logger';
import { sanitizeHTMLWithFallback } from '../utils/sanitizer';

// TipTap JSON å…§å®¹çš„å‹åˆ¥å®šç¾©
interface TipTapJSONContent {
  type: string;
  content?: TipTapJSONContent[];
  attrs?: Record<string, unknown>;
  text?: string;
  marks?: Array<{
    type: string;
    attrs?: Record<string, unknown>;
  }>;
}

// TipTap æ–‡ä»¶çš„æ ¹ç¯€é»å‹åˆ¥
interface TipTapDocument {
  type: 'doc';
  content: TipTapJSONContent[];
}

// è¯åˆå‹åˆ¥ï¼šæ”¯æ´çš„å…§å®¹æ ¼å¼
export type SupportedContent = TipTapDocument | TipTapJSONContent | string | null | undefined;

// FormText ç¯€é» - ä½¿ç”¨å·¥å» æ¨¡å¼å‰µå»º
const FormTextNode = createFormNode(FORM_NODE_TYPES.TEXT, formTextRenderStrategy);

// FormMenu ç¯€é» - ä½¿ç”¨å·¥å» æ¨¡å¼å‰µå»º
const FormMenuNode = createFormNode(FORM_NODE_TYPES.MENU, formMenuRenderStrategy);

/**
 * ç‚ºä»€éº¼éœ€è¦ FormTextNode å’Œ FormMenuNodeï¼Ÿ
 *
 * generateHTML() å‡½æ•¸éœ€è¦å°æ‡‰çš„ Node å®šç¾©ä¾†è™•ç† TipTap JSON ä¸­çš„è‡ªå®šç¾©ç¯€é»ï¼š
 *
 * 1. è½‰æ›æµç¨‹ï¼š
 *    TipTap JSON: {"type": "formtext", "attrs": {"promptData": {...}}}
 *    â†“ generateHTML æŸ¥æ‰¾ FormTextNode å®šç¾©
 *    â†“ èª¿ç”¨ FormTextNode.renderHTML() ä½¿ç”¨ formTextRenderStrategy
 *    â†“ ç”Ÿæˆ HTML: <span data-type="formtext">[name:value]</span>
 *    â†“ parseHtmlToText è½‰æ›ç‚ºç´”æ–‡å­—: [name:value]
 *
 * 2. æ²’æœ‰å°æ‡‰ Node å®šç¾©çš„å¾Œæœï¼š
 *    - generateHTML é‡åˆ°æœªçŸ¥ç¯€é»é¡å‹æœƒå¿½ç•¥æˆ–å ±éŒ¯
 *    - è¡¨å–®ç¯€é»ç„¡æ³•æ­£ç¢ºè½‰æ›ç‚ºå¯è®€æ–‡å­—æ ¼å¼
 *
 * 3. Node å®šç¾©æä¾›çš„é—œéµåŠŸèƒ½ï¼š
 *    - renderHTML(): å®šç¾©å¦‚ä½•å°‡ç¯€é»è½‰æ›ç‚º HTML å…ƒç´ 
 *    - parseHTML(): å®šç¾©å¦‚ä½•å¾ HTML è§£æå› TipTap ç¯€é»
 *    - å±¬æ€§è™•ç†ï¼šè™•ç†ç¯€é»çš„ attrs æ•¸æ“š
 */

// èˆ‡å¾Œå°åŒæ­¥çš„ TipTap æ“´å±•é…ç½®
const extensions = [
  TipTapStarterKit,
  TipTapTextStyle,
  TipTapTextAlign.configure({
    types: ['heading', 'paragraph'],
  }),
  FormTextNode,
  FormMenuNode,
  // æ³¨æ„ï¼šä¸åŒ…å« FontSize
];

/**
 * ç°¡å–®çš„ HTML è½‰ç´”æ–‡å­—å‡½æ•¸ï¼ˆç”¨æ–¼æ­¤æ¨¡çµ„å…§éƒ¨ï¼‰
 * é‡ç”¨ç¾æœ‰é‚è¼¯çš„ç°¡åŒ–ç‰ˆæœ¬
 */
function parseHtmlToText(html: string): string {
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = html;

  function traverse(node: globalThis.Node, parentTag?: string, depth: number = 0): string {
    if (node.nodeType === globalThis.Node.TEXT_NODE) {
      const text = node.textContent || '';
      if (!text.trim()) return '';
      return text.trim();
    } else if (node.nodeType === globalThis.Node.ELEMENT_NODE) {
      const element = node as HTMLElement;
      const tagName = element.tagName.toLowerCase();

      switch (tagName) {
        case 'p': {
          const content = traverseChildren(node, tagName, depth);
          if (parentTag === 'li') {
            return content;
          }
          if (!content.trim()) {
            return '\n';
          }
          return content + '\n';
        }
        case 'ul':
          return traverseChildren(node, tagName, depth + 1);
        case 'li': {
          // æ ¹æ“šæ·±åº¦åŠ å…¥ç¸®æ’ç©ºæ ¼
          const indent = '  '.repeat(depth);
          return `${indent}` + traverseChildren(node, tagName, depth) + '\n';
        }
        case 'br':
          return '\n';
        default: {
          // å°æ–¼æœªçŸ¥æ¨™ç±¤ï¼Œåªè¿”å›é–‹æ”¾æ¨™ç±¤ï¼Œä¸å¼·åˆ¶é—œé–‰
          // é€™æ¨£å¯ä»¥é¿å…ç›¸é„°æ¨™ç±¤è¢«éŒ¯èª¤åµŒå¥—
          const childContent = traverseChildren(node, tagName, depth);

          // è¿”å›é–‹æ”¾æ¨™ç±¤åŠ ä¸Šå­å…§å®¹
          return `<${tagName}>${childContent}`;
        }
      }
    }
    return '';
  }

  function traverseChildren(node: globalThis.Node, parentTag?: string, depth: number = 0): string {
    const childResults = Array.from(node.childNodes).map(child => traverse(child, parentTag, depth));
    return childResults.join('');
  }

  // ç›´æ¥è™•ç† tempDiv çš„å­ç¯€é»ï¼Œé¿å…åŒ…è£ div æ¨™ç±¤
  const childResults = Array.from(tempDiv.childNodes).map(child => traverse(child));
  const raw = childResults.join('');
  const final = raw.replace(/\n{3,}/g, '\n\n').trim();
  return final;
}

// function parseHtmlToText(html: string): string {
//     // ç›´æ¥è™•ç†åŸå§‹ HTML å­—ç¬¦ä¸²ï¼Œä¸ä½¿ç”¨ DOM è§£æ
//     // é€™æ¨£å¯ä»¥ä¿ç•™æ‰€æœ‰åŸå§‹å…§å®¹ï¼ŒåŒ…æ‹¬ä¸å®Œæ•´çš„æ¨™ç±¤å¦‚ <234234

//     let result = html;

//     // å°‡ <p> æ¨™ç±¤è½‰æ›ç‚ºæ›è¡Œ
//     result = result.replace(/<\/p>/gi, '\n');
//     result = result.replace(/<p[^>]*>/gi, '');

//     // å°‡ <br> æ¨™ç±¤è½‰æ›ç‚ºæ›è¡Œ
//     result = result.replace(/<br\s*\/?>/gi, '\n');

//     // æ¸…ç†å¤šé¤˜çš„æ›è¡Œï¼ˆ3å€‹æˆ–ä»¥ä¸Šè®Šæˆ2å€‹ï¼‰
//     result = result.replace(/\n{3,}/g, '\n\n');

//     // æ¸…ç†å‰å¾Œç©ºç™½
//     result = result.trim();

//     return result;
//   }

/**
 * å‹åˆ¥å®ˆè¡›ï¼šæª¢æŸ¥æ˜¯å¦ç‚ºæœ‰æ•ˆçš„ TipTap æ–‡ä»¶æ ¼å¼
 */
function isTipTapDocument(content: unknown): content is TipTapDocument {
  return (
    typeof content === 'object' &&
    content !== null &&
    'type' in content &&
    content.type === 'doc' &&
    'content' in content &&
    Array.isArray(content.content)
  );
}

/**
 * å°‡ TipTap JSON è½‰æ›ç‚ºç´”æ–‡å­—
 * ç”¨æ–¼æ’å…¥åˆ°ç¶²é çš„æ–‡å­—å…§å®¹
 *
 * @param jsonContent TipTap JSON å…§å®¹
 * @returns ç´”æ–‡å­—å­—ä¸²
 */
export function convertTipTapToPlainText(jsonContent: SupportedContent): string {
  try {
    // è™•ç†ç©ºå€¼
    if (!jsonContent) {
      return '';
    }

    // æ ¼å¼é©—è­‰
    if (isTipTapDocument(jsonContent)) {
      // æª¢æŸ¥å…§å®¹å®Œæ•´æ€§
      if (!jsonContent.content || !Array.isArray(jsonContent.content)) {
        logger.warn('TipTap JSON ç¼ºå°‘æœ‰æ•ˆçš„ content é™£åˆ—:', JSON.stringify(jsonContent));
        return '';
      }

      // ç”Ÿæˆ HTML ç„¶å¾Œè½‰ç‚ºç´”æ–‡å­—
      const html = generateHTML(jsonContent, extensions);
      console.log('ğŸ”„ convertTipTapToHTML çµæœ:', { html });
      const plainText = parseHtmlToText(html);
      return plainText;
    }

    // å¦‚æœæ˜¯å­—ä¸²ï¼Œç›´æ¥ä½¿ç”¨ç¾æœ‰çš„è½‰æ›é‚è¼¯
    if (typeof jsonContent === 'string') {
      return parseHtmlToText(jsonContent);
    }

    logger.warn('ç„¡æ•ˆçš„ TipTap JSON æ ¼å¼:', JSON.stringify(jsonContent));
    return '';
  } catch (error) {
    logger.error('TipTap JSON è½‰ç´”æ–‡å­—å¤±æ•—:', error instanceof Error ? error.message : 'Unknown error');

    // éŒ¯èª¤æ™‚å˜—è©¦ fallback è™•ç†
    if (typeof jsonContent === 'string') {
      return parseHtmlToText(jsonContent);
    }

    return '';
  }
}

/**
 * å°‡ TipTap JSON è½‰æ›ç‚º HTML
 * ç”¨æ–¼ Side Panel é è¦½é¡¯ç¤º
 *
 * @param jsonContent TipTap JSON å…§å®¹
 * @returns HTML å­—ä¸²
 */
export function convertTipTapToHTML(jsonContent: SupportedContent): string {
  try {
    // è™•ç†ç©ºå€¼
    if (!jsonContent) {
      return '<p></p>';
    }

    // æ ¼å¼é©—è­‰
    if (isTipTapDocument(jsonContent)) {
      // æª¢æŸ¥å…§å®¹å®Œæ•´æ€§
      if (!jsonContent.content || !Array.isArray(jsonContent.content)) {
        logger.warn('TipTap JSON ç¼ºå°‘æœ‰æ•ˆçš„ content é™£åˆ—:', JSON.stringify(jsonContent));
        return '<p></p>';
      }

      // ç›´æ¥ç”Ÿæˆ HTML
      const html = generateHTML(jsonContent, extensions);
      const result = html.trim() || '<p></p>';
      return result;
    }

    // å¦‚æœæ˜¯å­—ä¸²ï¼Œç›´æ¥è¿”å›ï¼ˆå‡è¨­å·²ç¶“æ˜¯ HTMLï¼‰
    if (typeof jsonContent === 'string') {
      return jsonContent.trim() || '<p></p>';
    }

    logger.warn('ç„¡æ•ˆçš„ TipTap JSON æ ¼å¼:', JSON.stringify(jsonContent));
    return '<p></p>';
  } catch (error) {
    logger.error('TipTap JSON è½‰ HTML å¤±æ•—:', error instanceof Error ? error.message : 'Unknown error');
    return '<p></p>';
  }
}

/**
 * æ™ºèƒ½å…§å®¹æ ¼å¼æª¢æ¸¬å’Œè½‰æ›
 * å„ªå…ˆä½¿ç”¨ JSON æ ¼å¼ï¼Œfallback åˆ° HTML æ ¼å¼
 *
 * @param contentJSON TipTap JSON å…§å®¹
 * @param content HTML å…§å®¹ï¼ˆå‘å¾Œç›¸å®¹ï¼‰
 * @returns ç´”æ–‡å­—å­—ä¸²
 */
export function getContentForInsertion(contentJSON?: SupportedContent, content?: string): string {
  // å„ªå…ˆä½¿ç”¨ JSON æ ¼å¼ (å°æ‡‰å¾Œå°ç­–ç•¥)
  if (contentJSON) {
    const plainText = convertTipTapToPlainText(contentJSON);
    if (plainText) {
      return plainText;
    }
  }

  // Fallback åˆ° HTML æ ¼å¼
  if (content) {
    return parseHtmlToText(content);
  }

  return '';
}

/**
 * æ™ºèƒ½å…§å®¹æ ¼å¼æª¢æ¸¬å’Œè½‰æ›ï¼ˆHTML è¼¸å‡ºï¼‰
 * å„ªå…ˆä½¿ç”¨ JSON æ ¼å¼ï¼Œfallback åˆ° HTML æ ¼å¼
 *
 * @param contentJSON TipTap JSON å…§å®¹
 * @param content HTML å…§å®¹ï¼ˆå‘å¾Œç›¸å®¹ï¼‰
 * @returns HTML å­—ä¸²
 */
export function getContentForPreview(contentJSON?: SupportedContent, content?: string): string {
  // å„ªå…ˆä½¿ç”¨ JSON æ ¼å¼ (å°æ‡‰å¾Œå°ç­–ç•¥)
  if (contentJSON) {
    const html = convertTipTapToHTML(contentJSON);
    if (html && html !== '<p></p>') {
      return html;
    }
  }

  // Fallback åˆ° HTML æ ¼å¼ - ä½¿ç”¨å®‰å…¨æ¸…ç†é˜²æ­¢ XSS
  if (content) {
    return sanitizeHTMLWithFallback(content, '<p></p>');
  }

  return '<p></p>';
}
